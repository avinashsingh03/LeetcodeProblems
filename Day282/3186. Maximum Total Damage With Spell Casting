class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        // Step 1: Group identical damages and sum their total damage
        unordered_map<int, long long> sum;
        for (int x : power) sum[x] += x;

        // Step 2: Extract and sort unique damage values
        vector<int> vals;
        vals.reserve(sum.size());
        for (auto &p : sum) vals.push_back(p.first);
        sort(vals.begin(), vals.end());

        int n = vals.size();
        if (n == 0) return 0;
        
        // Step 3: Initialize DP arrays
        vector<long long> total(n), dp(n);
        for (int i = 0; i < n; ++i) total[i] = sum[vals[i]];

        // Base case: take the first spell
        dp[0] = total[0];
        
        // Step 4: Build DP solution forward
        for (int i = 1; i < n; ++i) {
            // Find last non-conflicting position (vals[j] <= vals[i] - 3)
            int need = vals[i] - 3;
            int j = upper_bound(vals.begin(), vals.begin() + i, need) - vals.begin() - 1;
            
            // Option 1: Take current spell + best from non-conflicting position
            long long take = total[i] + (j >= 0 ? dp[j] : 0LL);
            
            // Option 2: Skip current spell, take previous best
            // Choose maximum of both options
            dp[i] = max(dp[i - 1], take);
        }
        
        // Step 5: Return maximum damage from all positions
        return dp.back();
    }
};
